# RLM Alignment Progress Notes

## Phase 1: Core `llm_query()` Infrastructure
**Completed:** 2026-01-21T13:57:15-08:00

### Implemented
- `_parse_pi_json_output(output)` - Extracts final assistant text from pi --mode json streaming JSONL output
- `_log_query(session_dir, entry)` - Appends query entries to `llm_queries.jsonl` with automatic timestamping
- `_spawn_sub_agent(prompt, remaining_depth, session_dir, cleanup, model, timeout)` - Spawns full pi subprocess for sub-queries
- `llm_query(prompt, cleanup=True)` - Exposed helper in REPL exec environment, uses global semaphore
- `_GLOBAL_CONCURRENCY_SEMAPHORE` - Global threading semaphore limiting concurrent spawns to 5
- `_migrate_state_v2_to_v3(state)` - Auto-migrates v2 states to v3 schema
- State version 3 schema with: `max_depth`, `remaining_depth`, `preserve_recursive_state`, `final_answer`

### Files Modified
- `skills/rlm/scripts/rlm_repl.py` - Added ~200 lines for LLM query infrastructure
- `skills/rlm/tests/__init__.py` - New (package marker)
- `skills/rlm/tests/conftest.py` - New (shared fixtures: `init_session`, `run_exec`, `--slow` marker)
- `skills/rlm/tests/test_phase1_llm_query.py` - New (27 tests: 25 unit, 2 slow integration)

### Validation Results
```
$ pytest skills/rlm/tests/test_phase1_llm_query.py -v
======================== 25 passed, 2 skipped in 0.15s =========================

$ pytest skills/rlm/tests/test_phase1_llm_query.py -v --slow -k "test_goal_"
======================= 2 passed, 25 deselected in 3.51s =======================
```

Manual smoke test:
```
$ python3 rlm_repl.py init test.txt
Session path: .pi/rlm_state/test-20260121-135659/state.pkl

$ python3 rlm_repl.py --state ... exec -c 'result = llm_query("Say only: PONG"); print(result)'
PONG

$ cat .../llm_queries.jsonl
{"query_id": "q_e2382286", "status": "success", "duration_ms": 1898, ...}
```

State version verified: 3 with all depth tracking fields.

### Notes
- No deviations from plan
- Tests use subprocess mocking for fast unit tests, real pi spawning for slow tests
- The `depth_level` in logs represents remaining_depth at call time (3 = root level)

---

## Phase 2: Depth Tracking & Recursive State
**Completed:** 2026-01-21T14:03:00-08:00

### Implemented
- `--max-depth N` argument for `init` command (default: 3 per paper spec)
- `--preserve-recursive-state` flag for debugging (keeps sub-session directories)
- `cmd_init()` updated to use CLI args for depth settings
- `cmd_status()` updated to display depth info in status output
- `llm_query()` updated to respect `preserve_recursive_state` flag (forces cleanup=False)

### Files Modified
- `skills/rlm/scripts/rlm_repl.py` - Modified ~50 lines (CLI args, cmd_init, cmd_status, llm_query)
- `skills/rlm/tests/test_phase2_depth.py` - New (23 tests: 22 unit, 1 slow integration)

### Validation Results
```
$ pytest skills/rlm/tests/test_phase2_depth.py -v
======================== 22 passed, 1 skipped in 0.55s =========================

$ pytest skills/rlm/tests/test_phase1_llm_query.py skills/rlm/tests/test_phase2_depth.py -v
======================== 47 passed, 3 skipped in 0.67s =========================

$ pytest skills/rlm/tests/test_phase2_depth.py -v --slow -k "test_goal_"
======================= 4 passed, 19 deselected in 2.16s =======================
```

Manual smoke test:
```
$ python3 rlm_repl.py init README.md --max-depth 2
Session path: .pi/rlm_state/readme-20260121-140242/state.pkl
...
Max depth: 2

$ python3 rlm_repl.py --state ... status
...
  Max depth: 2
  Remaining depth: 2
...

$ python3 rlm_repl.py init README.md --preserve-recursive-state
Session path: .pi/rlm_state/readme-20260121-140247/state.pkl
...
Preserve recursive state: enabled
```

### Goal-Alignment Verification
- [x] `--max-depth N` sets both `max_depth` and `remaining_depth`
- [x] Sub-agent receives decremented depth via `RLM_REMAINING_DEPTH` in system prompt
- [x] Depth-0 returns error without spawning subprocess
- [x] Directory structure matches `depth-N/q_xxx` pattern
- [x] Default depth is 3 (per paper spec)

### Notes
- No deviations from plan
- Recursive directory structure was already implemented in Phase 1; Phase 2 just adds CLI configuration
- `preserve_recursive_state` affects both direct `cleanup` param and state-based cleanup override

